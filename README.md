# Домашнє завдання 4: Порівняльний аналіз алгоритмів сортування

## Зміст

- [Домашнє завдання 4: Порівняльний аналіз алгоритмів сортування](#домашнє-завдання-4-порівняльний-аналіз-алгоритмів-сортування)
  - [Зміст](#зміст)
  - [Опис завдання](#опис-завдання)
  - [Методологія тестування](#методологія-тестування)
    - [Розміри наборів даних](#розміри-наборів-даних)
    - [Інструменти](#інструменти)
  - [Результати тестування](#результати-тестування)
    - [Випадкові дані](#випадкові-дані)
    - [Відсортовані дані](#відсортовані-дані)
    - [Зворотно відсортовані дані](#зворотно-відсортовані-дані)
    - [Майже відсортовані дані](#майже-відсортовані-дані)
    - [Великі масиви (тільки ефективні алгоритми)](#великі-масиви-тільки-ефективні-алгоритми)
  - [Аналіз результатів](#аналіз-результатів)
    - [Емпірична перевірка теоретичної складності](#емпірична-перевірка-теоретичної-складності)
      - [Insertion Sort - O(n²)](#insertion-sort---on)
      - [Merge Sort - O(n log n)](#merge-sort---on-log-n)
      - [Timsort - O(n) на відсортованих, O(n log n) на випадкових](#timsort---on-на-відсортованих-on-log-n-на-випадкових)
    - [Чому Timsort ефективніший?](#чому-timsort-ефективніший)
  - [Висновки](#висновки)
    - [Основні висновки](#основні-висновки)
    - [Чому програмісти використовують вбудовані алгоритми?](#чому-програмісти-використовують-вбудовані-алгоритми)
    - [Практичні рекомендації](#практичні-рекомендації)



## Опис завдання

Метою цього домашнього завдання є порівняння трьох алгоритмів сортування:
1. **Сортування злиттям (Merge Sort)**
2. **Сортування вставками (Insertion Sort)**
3. **Timsort** (вбудований алгоритм Python)

Порівняння проводиться за часом виконання на різних наборах даних з використанням модуля `timeit`.


## Методологія тестування

Тестування проводилося на чотирьох типах даних:

1. **Випадкові дані** - повністю випадкові числа
2. **Відсортовані дані** - вже відсортований масив
3. **Зворотно відсортовані** - масив у зворотному порядку
4. **Майже відсортовані** - 90% елементів на своїх місцях

### Розміри наборів даних

- Малі: 100, 1000 елементів
- Середні: 5000, 10000 елементів
- Великі: 50000, 100000 елементів

### Інструменти

Використано модуль `timeit` з усередненням результатів:
- 10 повторень для малих/середніх масивів
- 3 повторення для великих масивів

## Результати тестування

### Випадкові дані

| Розмір | Merge Sort | Insertion Sort | Timsort |
|--------|-----------|----------------|---------|
| 100 | 0.000057 с | 0.000065 с | **0.000003 с** |
| 1000 | 0.000742 с | 0.005735 с | **0.000029 с** |
| 5000 | 0.003505 с | 0.149369 с | **0.000259 с** |
| 10000 | 0.007521 с | 0.581465 с | **0.000609 с** |

**Спостереження:**
- Timsort найшвидший на всіх розмірах
- Insertion Sort різко сповільнюється при збільшенні розміру
- Merge Sort показує стабільну продуктивність

---

### Відсортовані дані

| Розмір | Merge Sort | Insertion Sort | Timsort |
|--------|-----------|----------------|---------|
| 100 | 0.000035 с | 0.000003 с | **0.000000 с** |
| 1000 | 0.000407 с | 0.000031 с | **0.000003 с** |
| 5000 | 0.002309 с | 0.000152 с | **0.000023 с** |
| 10000 | 0.004757 с | 0.000317 с | **0.000043 с** |

**Спостереження:**
- Timsort досягає O(n) на відсортованих даних
- Insertion Sort також ефективний (O(n))
- Merge Sort не використовує переваги відсортованості

---

### Зворотно відсортовані дані

| Розмір | Merge Sort | Insertion Sort | Timsort |
|--------|-----------|----------------|---------|
| 100 | 0.000034 с | 0.000100 с | **0.000000 с** |
| 1000 | 0.000418 с | 0.011181 с | **0.000004 с** |
| 5000 | 0.002380 с | 0.288392 с | **0.000024 с** |
| 10000 | 0.005087 с | 1.153878 с | **0.000044 с** |

**Спостереження:**
- Insertion Sort показує найгіршу продуктивність (O(n²))
- Timsort залишається найшвидшим
- Merge Sort стабільний

---

### Майже відсортовані дані

| Розмір | Merge Sort | Insertion Sort | Timsort |
|--------|-----------|----------------|---------|
| 100 | 0.000040 с | 0.000014 с | **0.000002 с** |
| 1000 | 0.000561 с | 0.001418 с | **0.000036 с** |
| 5000 | 0.003140 с | 0.033208 с | **0.000153 с** |
| 10000 | 0.006613 с | 0.134922 с | **0.000306 с** |

**Спостереження:**
- Timsort найефективніший завдяки виявленню природного порядку
- Insertion Sort показує хороші результати на малих масивах
- Merge Sort не адаптується до частково відсортованих даних

---

### Великі масиви (тільки ефективні алгоритми)

| Розмір | Merge Sort | Timsort |
|--------|-----------|---------|
| 50000 | 0.043108 с | **0.004012 с** |
| 100000 | 0.090505 с | **0.008043 с** |

**Спостереження:**
- Timsort у **10+ разів швидший** за Merge Sort
- Insertion Sort не тестувався (занадто повільний)

## Аналіз результатів

### Емпірична перевірка теоретичної складності

#### Insertion Sort - O(n²)

При збільшенні розміру у 10 разів (1000 → 10000) на випадкових даних:
- Час збільшився: 0.005735 с → 0.581465 с
- Коефіцієнт: **~101 раз** ≈ 10² ✓

Це підтверджує квадратичну складність O(n²).

#### Merge Sort - O(n log n)

При збільшенні розміру у 10 разів (10000 → 100000):
- Час збільшився: 0.007521 с → 0.090505 с
- Коефіцієнт: **~12 разів**
- Теоретично: 10 × log₂(10) ≈ 10 × 3.32 ≈ **13.3** ✓

Це підтверджує складність O(n log n).

#### Timsort - O(n) на відсортованих, O(n log n) на випадкових

На відсортованих даних (10000 → 100000):
- Час збільшився лінійно
- Підтверджує O(n) для відсортованих даних ✓

На випадкових даних поведінка схожа на Merge Sort, але з кращими константами.

### Чому Timsort ефективніший?

1. **Гібридний підхід:**
   - Використовує Insertion Sort для малих підмасивів (< 64 елементи)
   - Insertion Sort дуже швидкий на малих даних завдяки кращій локальності кешу

2. **Виявлення природного порядку:**
   - Знаходить вже відсортовані послідовності (runs)
   - Використовує їх без повторного сортування
   - На реальних даних часто є часткова впорядкованість

3. **Оптимізоване злиття:**
   - Використовує галопуючий режим (galloping mode)
   - Ефективніше зливає runs різної довжини
   - Менше порівнянь при злитті

4. **Адаптивність:**
   - Пристосовується до структури даних
   - Найкращий випадок O(n) замість O(n log n)
   - Стабільна продуктивність у гіршому випадку

## Висновки

### Основні висновки

1. **Insertion Sort:**
   - ✅ Ефективний лише на малих масивах (< 1000 елементів)
   - ✅ Відмінний на майже відсортованих даних
   - ❌ Неприйнятний для великих масивів через O(n²)

2. **Merge Sort:**
   - ✅ Стабільна продуктивність O(n log n)
   - ✅ Передбачувана поведінка на всіх типах даних
   - ❌ Не використовує природний порядок
   - ❌ Потребує додаткової пам'яті

3. **Timsort:**
   - ✅ Найефективніший у більшості випадків
   - ✅ Адаптується до структури даних
   - ✅ Використовує переваги обох алгоритмів
   - ✅ Оптимізований для реальних даних
   - ✅ У 10+ разів швидший за Merge Sort на великих масивах

### Чому програмісти використовують вбудовані алгоритми?

1. **Продуктивність:**
   - Timsort значно ефективніший за "класичні" алгоритми
   - Оптимізований на рівні C (CPython)
   - Використовує низькорівневі оптимізації

2. **Надійність:**
   - Перевірений мільйонами користувачів
   - Покритий тестами
   - Без помилок у реалізації

3. **Універсальність:**
   - Працює ефективно на різних типах даних
   - Адаптується до структури даних
   - Не потребує налаштування

4. **Підтримка:**
   - Розробляється експертами
   - Постійно оптимізується
   - Документована

5. **Час розробки:**
   - Не потрібно писати та тестувати власний код
   - Менше помилок
   - Швидша розробка

### Практичні рекомендації

- **Завжди використовуйте** `sorted()` або `.sort()` у Python
- **Пишіть власні алгоритми** тільки якщо:
  - Є специфічні вимоги до сортування
  - Потрібна особлива оптимізація
  - Це навчальний проект

> [!IMPORTANT]
> Емпіричні дані підтверджують, що Timsort є оптимальним вибором для більшості практичних задач. Поєднання сортування злиттям і вставками робить його набагато ефективнішим за окремі алгоритми.

